# Signal Handling in Unix

## Introduction
This document provides an overview of signal handling in Unix, including the types of signals, the signaling process, and practical code examples. Signal handling is a fundamental aspect of Unix system programming, allowing processes to respond to asynchronous events such as interrupts and exceptions.

## What are Signals?
Signals are a mechanism that allows a procedure to be invoked in response to a defined set of events. They provide a way for processes to communicate with each other and handle exceptional conditions.

## Phases in the Signaling Process
1. **Generation**: The signal is created.
2. **Delivery**: The signal is sent to the process.

## Signal Numbers
- In the original System V, there were **15 signals** (numbered 1-15).
- In System V and BSD, there are **31 signals** (numbered 1-31).

## Signal Handling
Each signal has a default action that the kernel performs if the process has not specified its own handling. The five possible default actions are:
1. **Abort**: Terminates the process after creating a core dump, which writes the contents of the process's address space and registers to a file called `core` in the current directory.
2. **Exit**: Terminates the process without generating a core dump.
3. **Ignore**: Ignores the signal.
4. **Stop**: Suspends the process.
5. **Continue**: Resumes the process if it was suspended; otherwise, the signal is ignored.

## What is a Signal Handler?
A process may choose to override the default action for a signal by specifying a custom signal handler.

## Special Signals
- **SIGKILL** and **SIGSTOP**: These signals cannot be blocked or ignored.

## Who Takes Action When a Signal is Given?
The receiving process is responsible for handling the signal.

## When Does the Kernel Become Aware of a Signal?
The kernel becomes aware of a signal when it calls `issig()` to check for pending signals.

## When is `issig()` Called?
- Before returning to user mode from a system interrupt.
- Just before blocking on an interruptible event.
- Immediately after waking up from an interruptible event.

## What Happens if `issig()` Returns True?
If `issig()` returns true, the kernel calls `psig()` to dispatch the signal. The process may terminate and generate a core dump if necessary, or `sendsig()` will invoke the user-defined handler and return the process to user mode, waiting until the handler completes.

## Common Unix Signals
1. **SIGABRT**: Process aborted (abort).
2. **SIGALRM**: Real-time alarm (exit).
3. **SIGCHLD**: Child process terminated (ignore).
4. **SIGCONT**: Resume suspended process.
5. **SIGHUP**: Terminal hangup (exit).
6. **SIGINT**: Terminal interrupt.
7. **SIGQUIT**: Terminal quit signal (abort).
8. **SIGKILL**: Kill process (exit).
9. **SIGSEGV**: Segmentation fault (abort).
10. **SIGSTOP**: Stop process.
11. **SIGTERM**: Terminate process.
12. **SIGTRAP**: Hardware fault.

## When Are Signals Generated?
Signals can be generated by:
- Exceptions.
- Other processes.
- Terminal interrupts.
- Job control.
- Quotas.
- Notifications.
- Alarms.

## Types of Alarms
1. **ITIMER_REAL**: Measures real time and generates the `SIGALRM` signal.
2. **ITIMER_VIRTUAL**: Measures virtual time; generates `SIGVTALRM` when the process is executing in user mode.
3. **ITIMER_PROF**: Measures total time used by the process in both user and kernel modes; generates `SIGPROF`.

## How Are Exceptions Handled?
Exceptions occur due to specific code errors at certain points in the program. When an exception occurs, the program traps the kernel, where the trap handler processes it. The kernel will then generate an appropriate signal for the process.

## Types of Sleep
1. **Interruptible Sleep**: The process waits on short-term events that are expected to complete soon, like disk I/O operations. Short-lived signals can't interrupt these processes.
2. **Uninterruptible Sleep**: Used when a process waits on long-term events or events that might not happen at all. The process is immediately woken up to handle the signal.

## What Happens When a Sleeping Process Receives a Signal?
- In **uninterruptible sleep**, the signal is kept pending but won't wake the process. The process becomes aware of the signal only after it returns to user mode.
- In **interruptible sleep**, any incoming signal will wake the process. The process checks for pending signals via `issig()`, and if there are any, it will handle the signal and abort its current system call.

## What are Unreliable Signals?
1. **Loss of Signal**: If multiple identical signals are sent to a process before it can handle them, only the first is processed; subsequent signals are lost.
2. **Interrupted System Calls**: When a signal interrupts a system call, it could fail with an error.
3. **Race Conditions**: A signal could arrive right after a process checks for pending signals, causing it to miss the signal entirely.

## Code Example to Show Unreliable Signals
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int signal_count = 0;

void signal_handler(int signum) {
    signal_count++;
    printf("Received signal %d, count: %d\n", signum, signal_count);
}

int main() {
    // Set up signal handler for SIGUSR1
    signal(SIGUSR1, signal_handler);

    printf("Program started. PID: %d\n", getpid());

    // Send SIGUSR1 to self multiple times
    for (int i = 0; i < 5; i++) {
        kill(getpid(), SIGUSR1);
    }

    // Small delay to allow signals to be handled
    sleep(1);

    // Display final count of signals received
    printf("Final signal count: %d\n", signal_count);

    return 0;
}


# Issues with Unreliable Signals

Unreliable signals present several challenges in Unix-based systems:

1. **Non-Persistent Signal Handlers**: Only one signal is caught. Once a signal is handled, the handler may be removed, leading to missed signals.

2. **Performance Issues with Sleeping Processes**: 
   - Signal handling data is stored in the user area in an array (`u_signal`). 
   - The kernel only reads the user area of the currently executing process.
   - Signals that are meant to be ignored can wake up processes that have handled them.
   - Ideally, the system should check if a signal should be ignored before waking the process.

3. **Lack of Signal Blocking**: There is a need to temporarily block signals until it is safe to handle them, which can lead to vulnerabilities in critical sections of code.

4. **No Support for Job Control**: There is no ability to group processes and suspend or resume them collectively.

---

# Advantages of Reliable Signals

Reliable signals address some of the limitations of unreliable signals:

1. **Persistent Handlers**: Signal handlers remain installed even after a signal occurs, eliminating the need for explicit reinstallation.

   ```c
   #include <stdio.h>
   #include <signal.h>
   #include <unistd.h>

   void handler(int signum) {
       printf("Persistent handler for signal %d invoked.\n", signum);
   }

   int main() {
       struct sigaction sa;
       sa.sa_handler = handler;
       sa.sa_flags = 0;  // No special flags
       sigemptyset(&sa.sa_mask);

       // Set the handler for SIGINT (Ctrl+C) to make it persistent
       if (sigaction(SIGINT, &sa, NULL) == -1) {
           perror("sigaction");
           return 1;
       }

       printf("Press Ctrl+C to invoke the handler.\n");

       // Infinite loop to keep the program running
       while (1) {
           sleep(1);
       }

       return 0;
   }

2. **Masking Signals**: Signals can be masked temporarily. When a process unblocks the signal, it will be posted and handled, allowing programmers to protect critical sections of code.
 
   ```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int signum) {
    printf("Handler invoked for signal %d\n", signum);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);

    // Set the handler for SIGUSR1
    sigaction(SIGUSR1, &sa, NULL);

    // Block SIGUSR1
    sigset_t block_set;
    sigemptyset(&block_set);
    sigaddset(&block_set, SIGUSR1);
    sigprocmask(SIG_BLOCK, &block_set, NULL);

    printf("SIGUSR1 is blocked. Sending signal...\n");
    raise(SIGUSR1);  // Send SIGUSR1

    printf("Unblocking SIGUSR1...\n");
    sigprocmask(SIG_UNBLOCK, &block_set, NULL);

    return 0;
}


### Sleeping Processes and Signal Handling
Signal information is visible to the kernel, allowing for selective handling of signals while a process is sleeping. Ignored signals will not interrupt the sleep:

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int main() {
    struct sigaction sa;
    sa.sa_handler = SIG_IGN;  // Ignore SIGUSR1
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);

    // Ignore SIGUSR1
    sigaction(SIGUSR1, &sa, NULL);

    printf("SIGUSR1 is ignored. Sleeping for 10 seconds...\n");

    // Sleep for 10 seconds
    sleep(10);

    printf("Woke up from sleep (not interrupted by SIGUSR1).\n");

    return 0;
}
```

### Unblocking and Waiting for Signals
The `sigpause` function can be used to unblock a signal and wait for it to arrive:

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int signum) {
    printf("Signal %d received during sigpause.\n", signum);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);

    // Set up handler for SIGUSR1
    sigaction(SIGUSR1, &sa, NULL);

    // Block SIGUSR1 initially
    sigset_t block_set;
    sigemptyset(&block_set);
    sigaddset(&block_set, SIGUSR1);
    sigprocmask(SIG_BLOCK, &block_set, NULL);

    printf("SIGUSR1 is blocked. Press enter to unblock and wait for signal...\n");
    getchar();

    // Unblock SIGUSR1 and wait for it
    sigset_t wait_set;
    sigemptyset(&wait_set);
    sigaddset(&wait_set, SIGUSR1);
    sigprocmask(SIG_UNBLOCK, &block_set, NULL);

    printf("Waiting for SIGUSR1 with sigpause...\n");
    sigsuspend(&wait_set);

    printf("Exiting after receiving SIGUSR1.\n");

    return 0;
}
```

## Limitations of SVR4 Signal Handling

While SVR4 provides reliable signal handling, it has several limitations:

1. **Single Signal Handling:**
   - The `sighold`, `sigrelse`, and `sigpause` functions can only operate on a single signal at a time.
   - This makes it difficult to manage multiple signals and can lead to race conditions.
2. **No Job Control:**
   - SVR4 lacks mechanisms for grouping and managing processes collectively.
3. **No Automatic System Call Restarting:**
   - If a signal interrupts a system call, the system call fails and must be explicitly restarted by the program.


**Here's the improved Markdown version:**

**BSD (4.2) Enhancements**

BSD 4.2 introduced several significant improvements in signal handling:

### 1. Signal Masking with `sigsetmask` and `sigblock`
These functions provide finer control over blocking and unblocking signals, reducing the risk of race conditions:

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("Signal %d received\n", sig);
}

int main() {
    // Block SIGINT and SIGTERM
    int mask = sigmask(SIGINT) | sigmask(SIGTERM);
    sigblock(mask);

    // Install signal handler
    signal(SIGINT, handler);

    // Unblock all signals in the mask and wait for a signal
    sigsetmask(0);  // Clear all masks (unblock)

    printf("Signals unblocked, waiting for SIGINT...\n");
    pause();

    return 0;
}
```

### 2. Persistent Handlers with `sigvec`
The `sigvec` function replaces the older `signal` function, allowing for persistent handlers and the specification of a signal mask to temporarily block signals during handler execution:

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("Handled signal %d\n", sig);
}

int main() {
    struct sigvec sv;
    sv.sv_handler = handler;
    sv.sv_mask = sigmask(SIGTERM);  // Block SIGTERM while SIGINT handler runs
    sv.sv_flags = 0;

    // Install the handler with `sigvec`
    sigvec(SIGINT, &sv, NULL);

    printf("Waiting for SIGINT...\n");
    pause();

    return 0;
}
```

### 3. Separate Signal Stacks with `sigstack`
This allows signal handlers to run on separate stacks, useful for managing user-defined stacks or avoiding stack overflows:

```c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

void handler(int sig) {
    printf("Handled signal %d on alternate stack\n", sig);
}

int main() {
    char alternate_stack[8192];  // Define a separate stack

    struct sigstack ss;
    ss.ss_sp = alternate_stack;
    ss.ss_onstack = 1;

    // Set up the separate stack for signal handling
    sigstack(&ss, NULL);

    struct sigvec sv;
    sv.sv_handler = handler;
    sv.sv_mask = 0;
    sv.sv_flags = SA_ONSTACK;

    // Install the handler to use the alternate stack
    sigvec(SIGSEGV, &sv, NULL);

    // Trigger a segmentation fault (SIGSEGV)
    printf("Triggering SIGSEGV...\n");
    int *ptr = NULL;
    *ptr = 1;  // This will cause a SIGSEGV

    return 0;
}
```

**SVR4 Signal Handling Enhancements**

SVR4 introduced several improvements in signal handling:

* **`sigprocmask`:** Provides more flexible control over signal masking.
* **`SIGALTSTACK`:** Allows for the use of alternate signal stacks.
* **`SIGSUSPEND`:** Provides atomic suspension of a process with a new signal mask.
* **`SIGACTION`:** Offers more advanced signal handling capabilities, including additional information about the signal.


**SVR4 Signal Handling Enhancements**

SVR4 introduced several improvements in signal handling:

* **`sigprocmask`:** Provides more flexible control over signal masking.
```c
#include <stdio.h>
#include <signal.h>

void handler(int sig) {
    printf("Handled signal %d\n", sig);
}

int main() {
    sigset_t mask, oldmask;

    // Initialize signal set to include SIGINT
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);

    // Block SIGINT
    sigprocmask(SIG_BLOCK, &mask, &oldmask);

    // Set up signal handler
    struct sigaction act;
    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(SIGINT, &act, NULL);

    // Critical section where SIGINT is blocked
    printf("SIGINT is now blocked\n");

    // Unblock SIGINT
    sigprocmask(SIG_SETMASK, &oldmask, NULL);

    printf("SIGINT unblocked, waiting for signal...\n");
    pause();

    return 0;
}
```

* **`SIGALTSTACK`:** Allows for the use of alternate signal stacks.
* **`SIGSUSPEND`:** Provides atomic suspension of a process with a new signal mask.
```c
#include <stdio.h>
#include <signal.h>

void handler(int sig) {
    printf("Handled signal %d\n", sig);
}

int main() {
    sigset_t mask, oldmask;

    // Initialize mask to block SIGINT
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);

    // Block SIGINT temporarily
    sigprocmask(SIG_BLOCK, &mask, &oldmask);

    // Set up signal handler
    struct sigaction act;
    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(SIGINT, &act, NULL);

    printf("Waiting for SIGINT...\n");

    // Suspend with SIGINT unblocked, waiting for a signal
    sigsuspend(&oldmask);

    return 0;
}
```

* **`SIGACTION`:** Offers more advanced signal handling capabilities, including additional information about the signal.
```c
#include <stdio.h>
#include <signal.h>

void handler(int sig, siginfo_t *info, void *context) {
    printf("Signal %d received with additional info\n", sig);
}

int main() {
    struct sigaction act;
    act.sa_sigaction = handler;
    act.sa_flags = SA_SIGINFO; // Provide additional signal information

    // Set up handler for SIGINT with additional info
    sigemptyset(&act.sa_mask);
    sigaction(SIGINT, &act, NULL);

    printf("Waiting for SIGINT...\n");
    pause();

    return 0;
}
```

**Kernel-Level Signal Handling**

* **U_AREA:**
    * `u_signal`: Vector of signal handlers for each signal.
    * `u_sigmask[]`: Signal masks associated with each handler.
    * `u_signalstack`: Pointer to the alternative signal stack.
    * `u_sigonstack`: Mask of signals to handle on the alternative stack.
    * `u_oldsig`: Set of handlers that exhibit the old, unreliable behavior.

* **PROC:**
    * `p_cursig`: The current signal being handled.
    * `p_sig`: Pending signal masks.
    * `p_hold`: ...
    * `p_ignore`: ...

**Signal Delivery and Handling**

1. **Signal Check:** The kernel checks if the signal is ignored or not.
2. **Pending Signals:** If not ignored, the signal is added to the `p_cursig` mask.
3. **Process Wakeup:** If the process is in an interruptible sleep state and the signal is not blocked, the kernel wakes up the process.

**Signal Delivery and Handling Process**

1. **Signal Check:** `issig()` checks for pending signals.
2. **Blocked Signals:** If `issig()` is true, the `p_hold` mask is checked to see if the signal is ready to be processed.
3. **Signal Handling:** `psig()` handles the signal.
4. **Flags and Behavior:** The `SA_NODEFER` flag allows a signal to remain unblocked while its handler is running.
5. **Executing the Handler:** `psig()` and `sendsig()` transition the process from kernel mode to user mode.

**Exceptions and Their Handling**

1. **Signal Generation**
2. **User-defined Handlers**
3. **Debugger Interaction**

**Limitations of Unix Signal Handling**

1. **Context Limitation:** The kernel only provides a portion of the process's context to the signal handler.
2. **Single-Threaded Focus:** Signals are primarily designed for single-threaded processes.
3. **Limited Debugging Capabilities:** `p_trace` has limited scope for debugging.

**Process Groups and Sessions**

* **Process Group:** A group of processes with a common parent.
* **Session:** A group of process groups.
* **Controlling Terminal:** A terminal associated with a session.

**SVR4 Session and Process Group Management**

* **`setsid`:** Creates a new session.
* **Session Leader:** Responsible for managing the session.
* **Controlling Terminal:** Associated with a session and foreground process group.

**4.4BSD Improvements**

* The process structure no longer directly references the session object but instead points to a process group object that links to the session structure.


