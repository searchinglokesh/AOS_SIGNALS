# Signal Handling in Unix

## What are Signals?
Signals are a mechanism that allows a procedure to be invoked in response to a defined set of events. They provide a way for processes to communicate with each other and handle exceptional conditions.

## Phases in the Signaling Process
1. **Generation**: The signal is created.
2. **Delivery**: The signal is sent to the process.

## Signal Numbers
- In the original System V, there were **15 signals** (numbered 1-15).
- In System V and BSD, there are **31 signals** (numbered 1-31).

## Signal Handling
Each signal has a default action that the kernel performs if the process has not specified its own handling. The five possible default actions are:
1. **Abort**: Terminates the process after creating a core dump, which writes the contents of the process's address space and registers to a file called `core` in the current directory.
2. **Exit**: Terminates the process without generating a core dump.
3. **Ignore**: Ignores the signal.
4. **Stop**: Suspends the process.
5. **Continue**: Resumes the process if it was suspended; otherwise, the signal is ignored.

## What is a Signal Handler?
A process may choose to override the default action for a signal by specifying a custom signal handler.

## Special Signals
- **SIGKILL** and **SIGSTOP**: These signals cannot be blocked or ignored.

## Who Takes Action When a Signal is Given?
The receiving process is responsible for handling the signal.

## When Does the Kernel Become Aware of a Signal?
The kernel becomes aware of a signal when it calls `issig()` to check for pending signals.

## When is `issig()` Called?
- Before returning to user mode from a system interrupt.
- Just before blocking on an interruptible event.
- Immediately after waking up from an interruptible event.

## What Happens if `issig()` Returns True?
If `issig()` returns true, the kernel calls `psig()` to dispatch the signal. The process may terminate and generate a core dump if necessary, or `sendsig()` will invoke the user-defined handler and return the process to user mode, waiting until the handler completes.

## Common Unix Signals
1. **SIGABRT**: Process aborted (abort).
2. **SIGALRM**: Real-time alarm (exit).
3. **SIGCHLD**: Child process terminated (ignore).
4. **SIGCONT**: Resume suspended process.
5. **SIGHUP**: Terminal hangup (exit).
6. **SIGINT**: Terminal interrupt.
7. **SIGQUIT**: Terminal quit signal (abort).
8. **SIGKILL**: Kill process (exit).
9. **SIGSEGV**: Segmentation fault (abort).
10. **SIGSTOP**: Stop process.
11. **SIGTERM**: Terminate process.
12. **SIGTRAP**: Hardware fault.

## When Are Signals Generated?
Signals can be generated by:
- Exceptions.
- Other processes.
- Terminal interrupts.
- Job control.
- Quotas.
- Notifications.
- Alarms.

## Types of Alarms
1. **ITIMER_REAL**: Measures real time and generates the `SIGALRM` signal.
2. **ITIMER_VIRTUAL**: Measures virtual time; generates `SIGVTALRM` when the process is executing in user mode.
3. **ITIMER_PROF**: Measures total time used by the process in both user and kernel modes; generates `SIGPROF`.

## How Are Exceptions Handled?
Exceptions occur due to specific code errors at certain points in the program. When an exception occurs, the program traps the kernel, where the trap handler processes it. The kernel will then generate an appropriate signal for the process.

## Types of Sleep
1. **Interruptible Sleep**: The process waits on short-term events that are expected to complete soon, like disk I/O operations. Short-lived signals can't interrupt these processes.
2. **Uninterruptible Sleep**: Used when a process waits on long-term events or events that might not happen at all. The process is immediately woken up to handle the signal.

## What Happens When a Sleeping Process Receives a Signal?
- In **uninterruptible sleep**, the signal is kept pending but won't wake the process. The process becomes aware of the signal only after it returns to user mode.
- In **interruptible sleep**, any incoming signal will wake the process. The process checks for pending signals via `issig()`, and if there are any, it will handle the signal and abort its current system call.

## What are Unreliable Signals?
1. **Loss of Signal**: If multiple identical signals are sent to a process before it can handle them, only the first is processed; subsequent signals are lost.
2. **Interrupted System Calls**: When a signal interrupts a system call, it could fail with an error.
3. **Race Conditions**: A signal could arrive right after a process checks for pending signals, causing it to miss the signal entirely.

## Code Example to Show Unreliable Signals
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int signal_count = 0;

void signal_handler(int signum) {
    signal_count++;
    printf("Received signal %d, count: %d\n", signum, signal_count);
}

int main() {
    // Set up signal handler for SIGUSR1
    signal(SIGUSR1, signal_handler);

    printf("Program started. PID: %d\n", getpid());

    // Send SIGUSR1 to self multiple times
    for (int i = 0; i < 5; i++) {
        kill(getpid(), SIGUSR1);
    }

    // Small delay to allow signals to be handled
    sleep(1);

    // Display final count of signals received
    printf("Final signal count: %d\n", signal_count);

    return 0;
}
```

# Issues with Unreliable Signals

Unreliable signals present several challenges in Unix-based systems:

1. **Non-Persistent Signal Handlers**: Only one signal is caught. Once a signal is handled, the handler may be removed, leading to missed signals.

2. **Performance Issues with Sleeping Processes**: 
   - Signal handling data is stored in the user area in an array (`u_signal`). 
   - The kernel only reads the user area of the currently executing process.
   - Signals that are meant to be ignored can wake up processes that have handled them.
   - Ideally, the system should check if a signal should be ignored before waking the process.

3. **Lack of Signal Blocking**: There is a need to temporarily block signals until it is safe to handle them, which can lead to vulnerabilities in critical sections of code.

4. **No Support for Job Control**: There is no ability to group processes and suspend or resume them collectively.


# What are the Advantages of Reliable Signals

## Persistent Handler
Signal handlers remain installed even after the signal occurs, eliminating the need for explicit reinstallation.

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int signum) {
    printf("Persistent handler for signal %d invoked.\n", signum);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;  // No special flags
    sigemptyset(&sa.sa_mask);

    // Set the handler for SIGINT (Ctrl+C) with `sigaction` to make it persistent
    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("sigaction");
        return 1;
    }

    printf("Press Ctrl+C to invoke the handler.\n");

    // Infinite loop to keep the program running
    while (1) {
        sleep(1);
    }

    return 0;
}
```

## Masking
Signals can be temporarily masked. When the process unlocks the signal, the signal will be posted and handled. This allows programmers to protect critical sections of code.

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int signum) {
    printf("Handler invoked for signal %d\n", signum);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);

    // Set the handler for SIGUSR1
    sigaction(SIGUSR1, &sa, NULL);

    // Block SIGUSR1
    sigset_t block_set;
    sigemptyset(&block_set);
    sigaddset(&block_set, SIGUSR1);
    sigprocmask(SIG_BLOCK, &block_set, NULL);

    printf("SIGUSR1 is blocked. Sending signal...\n");
    raise(SIGUSR1);  // Send SIGUSR1

    printf("Unblocking SIGUSR1...\n");
    sigprocmask(SIG_UNBLOCK, &block_set, NULL);

    return 0;
}
```

## Sleeping Processes
Some signal information is visible to the kernel. If a signal is sent to a process that is in interruptible sleep and the signal handler is set to ignore it, the kernel will not wake it up.

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int main() {
    struct sigaction sa;
    sa.sa_handler = SIG_IGN;  // Ignore SIGUSR1
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);

    // Ignore SIGUSR1
    sigaction(SIGUSR1, &sa, NULL);

    printf("SIGUSR1 is ignored. Sleeping for 10 seconds...\n");

    // Sleep for 10 seconds
    sleep(10);

    printf("Woke up from sleep (not interrupted by SIGUSR1).\n");

    return 0;
}
```

## Unblock and Wait
Using `sigpause` to unblock and wait for a signal to arrive.

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int signum) {
    printf("Signal %d received during sigpause.\n", signum);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);

    // Set up handler for SIGUSR1
    sigaction(SIGUSR1, &sa, NULL);

    // Block SIGUSR1 initially
    sigset_t block_set;
    sigemptyset(&block_set);
    sigaddset(&block_set, SIGUSR1);
    sigprocmask(SIG_BLOCK, &block_set, NULL);

    printf("SIGUSR1 is blocked. Press enter to unblock and wait for signal...\n");
    getchar();

    // Unblock SIGUSR1 and wait for it
    sigset_t wait_set;
    sigemptyset(&wait_set);
    sigaddset(&wait_set, SIGUSR1);
    sigprocmask(SIG_UNBLOCK, &block_set, NULL);

    printf("Waiting for SIGUSR1 with sigpause...\n");
    sigsuspend(&wait_set);

    printf("Exiting after receiving SIGUSR1.\n");

    return 0;
}
```

## Issues with SVR4
SVR4 provides all the reliable features but has the following limitations:
1. **Single Signal Handling**: `sighold`, `sigrelse`, and `sigpause` operate on only one signal at a time. If multiple signals need to be blocked or unblocked, there is no good way to handle them, which can lead to race conditions.
2. **No Job Control**: Processes cannot be grouped and managed collectively.
3. **No Automatic System Call Restarting**: If a signal interrupts a system call, the system call fails and needs to be explicitly restarted by the program.

## Improvements in BSD (4.2)
BSD (4.2) provided the following enhancements:
1. **Signal Masking with `sigsetmask` and `sigblock`**: A 32-bit bitmask representing signals offers more control over blocking and unblocking signals to avoid race conditions.

    ```c
    #include <stdio.h>
    #include <signal.h>
    #include <unistd.h>

    void handler(int sig) {
        printf("Signal %d received\n", sig);
    }

    int main() {
        // Block SIGINT and SIGTERM
        int mask = sigmask(SIGINT) | sigmask(SIGTERM);
        sigblock(mask);

        // Install signal handler
        signal(SIGINT, handler);

        // Unblock all signals in the mask and wait for a signal
        sigsetmask(0);  // Clear all masks (unblock)
        
        printf("Signals unblocked, waiting for SIGINT...\n");
        pause();

        return 0;
    }
    ```

2. **Persistent Handlers with `sigvec`**: `sigvec` replaces the `signal` call, allowing persistent handling and specifying a mask to temporarily block signals.

    ```c
    #include <stdio.h>
    #include <signal.h>
    #include <unistd.h>

    void handler(int sig) {
        printf("Handled signal %d\n", sig);
    }

    int main() {
        struct sigvec sv;
        sv.sv_handler = handler;
        sv.sv_mask = sigmask(SIGTERM);  // Block SIGTERM while SIGINT handler runs
        sv.sv_flags = 0;

        // Install the handler with `sigvec`
        sigvec(SIGINT, &sv, NULL);

        printf("Waiting for SIGINT...\n");
        pause();

        return 0;
    }
    ```

3. **Separate Signal Stacks with `sigstack`**: This allows signal handlers to run on a separate stack, managing user-defined stacks or avoiding stack overflow.

    ```c
    #include <stdio.h>
    #include <signal.h>
    #include <stdlib.h>
    #include <unistd.h>

    void handler(int sig) {
        printf("Handled signal %d on alternate stack\n", sig);
    }

    int main() {
        char alternate_stack[8192];  // Define a separate stack

        struct sigstack ss;
        ss.ss_sp = alternate_stack;
        ss.ss_onstack = 1;

        // Set up the separate stack for signal handling
        sigstack(&ss, NULL);

        struct sigvec sv;
        sv.sv_handler = handler;
        sv.sv_mask = 0;
        sv.sv_flags = SA_ONSTACK;

        // Install the handler to use the alternate stack
        sigvec(SIGSEGV, &sv, NULL);

        // Trigger a segmentation fault (SIGSEGV)
        printf("Triggering SIGSEGV...\n");
        int *ptr = NULL;
        *ptr = 1;  // This will cause a SIGSEGV

        return 0;
    }
    ```

4. **Job Control and Automatic Restart of System Calls**


# Signals in SVR4

## 1) `sigprocmask`
`sigprocmask` is used to manipulate the signal mask to block, unblock, or set signals. It is very useful for critical sections.

```c
#include <stdio.h>
#include <signal.h>

void handler(int sig) {
    printf("Handled signal %d\n", sig);
}

int main() {
    sigset_t mask, oldmask;
    
    // Initialize signal set to include SIGINT
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);

    // Block SIGINT
    sigprocmask(SIG_BLOCK, &mask, &oldmask);

    // Set up signal handler
    struct sigaction act;
    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(SIGINT, &act, NULL);

    // Critical section where SIGINT is blocked
    printf("SIGINT is now blocked\n");

    // Unblock SIGINT
    sigprocmask(SIG_SETMASK, &oldmask, NULL);

    printf("SIGINT unblocked, waiting for signal...\n");
    pause();

    return 0;
}
```

## 2) `SIGALTSTACK`
`SIGALTSTACK` allows the use of a new stack to handle signals.

## 3) `SIGSUSPEND`
`SIGSUSPEND` enables a process to set a new mask and suspend itself until a signal arrives. This is atomic.

```c
#include <stdio.h>
#include <signal.h>

void handler(int sig) {
    printf("Handled signal %d\n", sig);
}

int main() {
    sigset_t mask, oldmask;

    // Initialize mask to block SIGINT
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);

    // Block SIGINT temporarily
    sigprocmask(SIG_BLOCK, &mask, &oldmask);

    // Set up signal handler
    struct sigaction act;
    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(SIGINT, &act, NULL);

    printf("Waiting for SIGINT...\n");
    
    // Suspend with SIGINT unblocked, waiting for a signal
    sigsuspend(&oldmask);

    return 0;
}
```

## 4) `SIGACTION`
`SIGACTION` is used to set up signal handlers and can provide additional information about the signal received.

```c
#include <stdio.h>
#include <signal.h>

void handler(int sig, siginfo_t *info, void *context) {
    printf("Signal %d received with additional info\n", sig);
}

int main() {
    struct sigaction act;
    act.sa_sigaction = handler;
    act.sa_flags = SA_SIGINFO; // Provide additional signal information

    // Set up handler for SIGINT with additional info
    sigemptyset(&act.sa_mask);
    sigaction(SIGINT, &act, NULL);

    printf("Waiting for SIGINT...\n");
    pause();

    return 0;
}
```

# States of Signals in Kernel

## U_AREA
- **u_signal**: A vector of signal handlers for each signal.
- **u_sigmask[]**: Signal masks associated with each handler.
- **u_signalstack**: A pointer to the alternative signal stack.
- **u_sigonstack**: A mask of signals to handle on the alternative stack.
- **u_oldsig**: A set of handlers that exhibit the old, unreliable behavior.

## PROC
- **p_cursig**: The current signal being handled.
- **p_sig**: Pending signal masks.
- **p_hold**: 
- **p_ignore**: 

# What Happens When a Signal is Generated

1. **Signal Check**: The kernel first checks the process structure of the receiving process to determine if it has ignored the signal. If the signal is not ignored, it takes action.
2. **Pending Signals**: If the signal is not ignored, it is added to `p_cursig`. Only one instance is stored since it uses a bitmask (0 or 1).
3. **Process Wakeup**: If the process is in an interruptible sleep state and the signal is not blocked, the kernel wakes up the process.

# How Are Signals Delivered and Handled?

1. **Signal Check**: The function `issig()` checks for pending signals.
2. **Blocked Signals**: If `issig()` returns true, the kernel checks if the `p_hold` mask has a signal, indicating that it is ready to process.
3. **Signal Handling**: The function `psig()` is used to handle the signal.
4. **Flags and Behavior**: The flag `SA_NODEFER` allows the signal to remain unblocked while its handler runs.
5. **Executing the Handler**: The functions `psig()` and `sendsig()` transition the process from kernel mode to user mode to execute the handler.

# What Are Exceptions and How Are They Handled?

1. **Signal Generation**
2. **User-Defined Handlers**
3. **Debugger Interaction**

# Why Unix Is Poor with Exception Handling

1. **Context Limitation**: The kernel only has a portion of the context available to the handler.
2. **Single-Thread Focus**: Signals are designed primarily for single-threaded processes.
3. **Limited Scope for Debugging**: The `p_trace` functionality has limited capability for debugging.

# What Is a Process Group?

Every process belongs to a process group identified by its process group ID (PGID). The kernel can perform actions on all processes within a group. Each group has a leader or parent, and processes inherit their PGID from their parent.

# What Is the Special File That Represents the Controlling Terminal of Each Process?

The special file is `/dev/tty`.

# What Is a Controlling Group?

The terminal is associated with a process group identified in the terminal's structure.

# How Does SVR3 Manage?

- **Process Groups**: Managed using `fork()` and `setpgrp()` to change the process group.
- **Controlling Terminal**: The terminal is linked to the controlling group.
- **Terminal Access**: No job control is provided.
- **Terminal Signals**: 
- **Death of Group Leader**: Leads to dissociation from the controlling terminal.

### Limitations
- Lack of ability for a group to close its controlling terminal and allocate a new one.
- Login sessions cannot persist after disconnecting from the controlling terminal.
- Loss of carrier is not handled.

# What Improvements Does BSD (4.3) Offer Over SVR3, and What Drawbacks Remain?

1. **Lack of Clear Representation**: The lack of a clear representation of login sessions can lead to issues.
2. **Absence of a Single Responsible Process**: 
3. **Terminal's Controlling Group**: Processes can change the terminal's controlling group, leading to complications.

# How Does SVR4 Manage Sessions and Process Groups?

1. Each process belongs to both a session and a process group.
2. The controlling terminal is associated with a session and the foreground process group.
3. The session leader is responsible for managing the session.
4. The `setsid` function is used to create a new session.

# SVR4 Data Structures

1. The `setsid` call allocates a new session structure.
2. When the session leader opens a terminal, it becomes the controlling terminal for that session.
3. Child processes inherit pointers to the session structure.

# What Are the Controlling Terminals?

The `/dev/tty` file serves as an alias for the controlling terminal.

# Improvements of 4.4BSD

1. The process structure does not directly reference the session object but instead points to the process group object that links to the session structure.
